{
  "author": "",
  "category": "General",
  "extensionNamespace": "",
  "fullName": "Fps controls 3D",
  "helpPath": "",
  "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyMy4wLjMsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iSWNvbnMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB2aWV3Qm94PSIwIDAgMzIgMzIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDMyIDMyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+DQo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPg0KCS5zdDB7ZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDt9DQo8L3N0eWxlPg0KPHBhdGggY2xhc3M9InN0MCIgZD0iTTEzLDE5Ljl2Mi44Yy00LjksMC45LTguNiwzLjgtOSw3LjRIMjhjLTAuNC0zLjYtNC4xLTYuNS05LTcuNFYyMCIvPg0KPHBhdGggY2xhc3M9InN0MCIgZD0iTTIxLjcsMjMuNGMtMC44LDEuMy0zLDIuMi01LjcsMi4yYy0yLjYsMC00LjktMC45LTUuNy0yLjIiLz4NCjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik0yMS43LDE3SDEwLjNDOC41LDE3LDcsMTUuNSw3LDEzLjdWOS4zQzcsNy41LDguNSw2LDEwLjMsNmgxMS41QzIzLjUsNiwyNSw3LjUsMjUsOS4zdjQuNQ0KCUMyNSwxNS41LDIzLjUsMTcsMjEuNywxN3oiLz4NCjxsaW5lIGNsYXNzPSJzdDAiIHgxPSIxMyIgeTE9IjEwIiB4Mj0iMTkiIHkyPSIxMCIvPg0KPHBhdGggY2xhc3M9InN0MCIgZD0iTTIxLjUsMTdjLTEuNSwyLjUtMy43LDQtNS41LDRjLTEuOCwwLTQtMS41LTUuNS00Ii8+DQo8cGF0aCBjbGFzcz0ic3QwIiBkPSJNOS40LDYuMUMxMC42LDMuNSwxMi43LDIsMTYsMmMzLjMsMCw1LjQsMS41LDYuNiw0LjEiLz4NCjwvc3ZnPg0K",
  "name": "FpsControls3D",
  "previewIconUrl": "https://asset-resources.gdevelop.io/public-resources/Icons/Line Hero Pack/Master/SVG/Virtual Reality/533efd0f9504b43bba7ab65c19e1c1408ab19c1c010efdf4e27b90e900cf91d4_Virtual Reality_vr_glasses_goggles_headset_user.svg",
  "shortDescription": "Fps controls 3D",
  "version": "0.1",
  "description": "Fps controls 3D",
  "tags": [
    "fps controls 3d platform collision jump gravity"
  ],
  "authorIds": [
    "W0yoMQqOeiULIwY1i1Qd8tprOyD2"
  ],
  "dependencies": [],
  "eventsFunctions": [
    {
      "description": "Collision system ",
      "fullName": "Collision system ",
      "functionType": "Action",
      "name": "CollisionDefault",
      "sentence": "Collision system for: _PARAM1_ Distance for scanning around: _PARAM2_ Obstacles names: _PARAM3_ Collision offset: _PARAM4_ Depth array: _PARAM5_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!runtimeScene) {",
            "  return;",
            "}",
            "",
            "const layer = runtimeScene.getLayer(\"\");",
            "const threeCamera = layer.getRenderer().getThreeCamera();",
            "const threeScene = layer.getRenderer().getThreeScene();",
            "const renderer = runtimeScene.getGame().getRenderer().getThreeRenderer();",
            "",
            "if (!threeScene.raycasterMap) {",
            "  threeScene.raycasterMap = new Map();",
            "}",
            "",
            "if (objects.length > 0) {",
            "  const objectName = objects[0].getName();",
            "  const playerObjects = runtimeScene.getObjects(objectName);",
            "",
            "  if (playerObjects.length === 0) {",
            "    return;",
            "  }",
            "",
            "  const player = playerObjects[0];",
            "  const playerName = player.getName();",
            "  const threePlayer = threeScene.getObjectByName(playerName);",
            "  const objectAngle = player.getAngle();",
            "  const distanceRay = eventsFunctionContext.getArgument(\"distanceRay\");",
            "  const targetObjects = eventsFunctionContext.getArgument(\"targetNames\").replace(/\\s+/g, '').split(',');",
            "  const levelOffsets = eventsFunctionContext.getArgument(\"levelOffsets\").replace(/\\s+/g, '').split(',').map(Number);",
            "  const collisionRadius = eventsFunctionContext.getArgument(\"collisionOffset\");",
            "",
            "  const halfWidth = player.getWidth() / 2;",
            "  const halfHeight = player.getHeight() / 2;",
            "  const halfDepth = player.getDepth() / 2;",
            "  const raycastingVar = runtimeScene.getVariables().get(\"_raycasting_instanced_mesh\");",
            "",
            "  const angles = [0, 45, 90, 135, 180, 225, 270, 315];",
            "  const raycasters = {};",
            "",
            "  levelOffsets.forEach((offset, levelIndex) => {",
            "    const playerPosition = new THREE.Vector3(",
            "      player.getCenterXInScene(),",
            "      -player.getCenterYInScene(),",
            "      player.getCenterZInScene() + player.getDepth() * offset",
            "    );",
            "",
            "    angles.forEach((angleOffset, angleIndex) => {",
            "      const angle = objectAngle + angleOffset;",
            "      const horizontalAngleRadians = THREE.MathUtils.degToRad(angle);",
            "      const verticalAngleRadians = 0;",
            "",
            "      const direction = new THREE.Vector3(",
            "        Math.cos(verticalAngleRadians) * Math.cos(horizontalAngleRadians),",
            "        Math.cos(verticalAngleRadians) * -Math.sin(horizontalAngleRadians),",
            "        Math.sin(verticalAngleRadians)",
            "      ).normalize();",
            "",
            "      const rayName = `rayLevel${levelIndex}Angle${angleIndex}${playerName}`;",
            "      raycasters[rayName] = new THREE.Raycaster(playerPosition, direction, 0, distanceRay);",
            "    });",
            "  });",
            "",
            "  function handleCollisions(rayName, position) {",
            "    const raycaster = raycasters[rayName];",
            "    const intersects = [];",
            "",
            "    threeScene.traverse((child) => {",
            "      if (child.isMesh && targetObjects.includes(child.name)) {",
            "        const childIntersects = raycaster.intersectObject(child, true);",
            "        childIntersects.forEach((intersect) => {",
            "          intersects.push(intersect);",
            "        });",
            "      }",
            "    });",
            "",
            "    if (intersects.length > 0) {",
            "      const firstIntersect = intersects[0];",
            "      const intersectedX = firstIntersect.point.x;",
            "      const intersectedY = firstIntersect.point.y;",
            "",
            "      const collided = (",
            "        position.x + halfWidth > intersectedX - collisionRadius &&",
            "        position.x - halfWidth < intersectedX + collisionRadius &&",
            "        position.y + halfHeight > intersectedY - collisionRadius &&",
            "        position.y - halfHeight < intersectedY + collisionRadius",
            "      );",
            "",
            "      if (collided) {",
            "        const deltaX = position.x - intersectedX;",
            "        const deltaY = position.y - intersectedY;",
            "        const moveBackDistance = 0.1;",
            "",
            "        if (Math.abs(deltaX) > Math.abs(deltaY)) {",
            "          if (deltaX > 0) {",
            "            player.setCenterXInScene(intersectedX + collisionRadius + halfWidth + moveBackDistance);",
            "          } else {",
            "            player.setCenterXInScene(intersectedX - collisionRadius - halfWidth + moveBackDistance);",
            "          }",
            "        } else {",
            "          if (deltaY > 0) {",
            "            player.setCenterYInScene(-(intersectedY + collisionRadius + halfHeight + moveBackDistance));",
            "          } else {",
            "            player.setCenterYInScene(-(intersectedY - collisionRadius - halfHeight - moveBackDistance));",
            "          }",
            "        }",
            "      }",
            "",
            "      raycastingVar.getChildNamed(rayName + \"_intersected\").setString(\"true\");",
            "      raycastingVar.getChildNamed(rayName + \"x\").setNumber(firstIntersect.point.x);",
            "      raycastingVar.getChildNamed(rayName + \"y\").setNumber(firstIntersect.point.y);",
            "      raycastingVar.getChildNamed(rayName + \"z\").setNumber(firstIntersect.point.z);",
            "      raycastingVar.getChildNamed(rayName + \"distance\").setNumber(firstIntersect.distance);",
            "    } else {",
            "      raycastingVar.getChildNamed(rayName + \"_intersected\").setString(\"false\");",
            "    }",
            "  }",
            "",
            "  levelOffsets.forEach((offset, levelIndex) => {",
            "    const playerPosition = new THREE.Vector3(",
            "      player.getCenterXInScene(),",
            "      -player.getCenterYInScene(),",
            "      player.getCenterZInScene() + player.getDepth() * offset",
            "    );",
            "",
            "    angles.forEach((angleOffset, angleIndex) => {",
            "      handleCollisions(`rayLevel${levelIndex}Angle${angleIndex}${playerName}`, playerPosition); ",
            "    });",
            "  });",
            "",
            "  const bottomRays = [",
            "    new THREE.Vector3(player.getCenterXInScene() - halfWidth, -player.getCenterYInScene(), player.getCenterZInScene()), ",
            "    new THREE.Vector3(player.getCenterXInScene() + halfWidth, -player.getCenterYInScene(), player.getCenterZInScene()), ",
            "    new THREE.Vector3(player.getCenterXInScene(), -player.getCenterYInScene() - halfHeight, player.getCenterZInScene()), ",
            "    new THREE.Vector3(player.getCenterXInScene(), -player.getCenterYInScene() + halfHeight, player.getCenterZInScene())  ",
            "  ];",
            "",
            "  const bottomDirection = new THREE.Vector3(0, 0, -1); ",
            "",
            "  bottomRays.forEach((rayPosition, index) => {",
            "    const rayName = `bottomRay${index}${playerName}`;",
            "    raycasters[rayName] = new THREE.Raycaster(rayPosition, bottomDirection, 0, distanceRay);",
            "  });",
            "",
            "  const allIntersections = [];",
            "",
            "  function handleBottomCollisions(rayName, position) {",
            "    const raycaster = raycasters[rayName];",
            "    const intersects = [];",
            "",
            "    threeScene.traverse((child) => {",
            "      if (child.isMesh && targetObjects.includes(child.name)) {",
            "        const childIntersects = raycaster.intersectObject(child, true);",
            "        childIntersects.forEach((intersect) => {",
            "          intersects.push(intersect);",
            "        });",
            "      }",
            "    });",
            "",
            "    if (!threePlayer.userData) {",
            "      threePlayer.userData = {};",
            "    }",
            "",
            "    if (intersects.length > 0) {",
            "      allIntersections.push(...intersects);",
            "    }",
            "  }",
            "",
            "  if (!threePlayer.userData) {",
            "    threePlayer.userData = {};",
            "  }",
            "",
            "  bottomRays.forEach((rayPosition, index) => {",
            "    handleBottomCollisions(`bottomRay${index}${playerName}`, rayPosition); ",
            "  });",
            "",
            " ",
            "  if (allIntersections.length > 0) {",
            "    const bestIntersect = allIntersections.reduce((best, current) => {",
            "      if (current.point.z > best.point.z) {",
            "        return current;",
            "      } else if (current.point.z === best.point.z && current.distance < best.distance) {",
            "        return current;",
            "      }",
            "      return best;",
            "    }, allIntersections[0]);",
            "",
            "    threePlayer.userData.intersectedZ = bestIntersect.point.z;",
            "    threePlayer.userData.intersected = true;",
            "  } else {",
            "    threePlayer.userData.intersectedZ = 0;",
            "    threePlayer.userData.intersected = false;",
            "  }",
            "",
            "  renderer.render(threeScene, threeCamera);",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Object3D",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Distance around ",
          "name": "distanceRay",
          "type": "expression"
        },
        {
          "description": "Obstacle objects names (\"name1,name2,...\")",
          "name": "targetNames",
          "type": "string"
        },
        {
          "description": "collisionOffset",
          "name": "collisionOffset",
          "type": "expression"
        },
        {
          "description": "Depth array",
          "longDescription": "The object's depth values to cast rays from.\nExample: \"-0.5,-0.25,0,0.25,0.5\"",
          "name": "levelOffsets",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Landing and jumping",
      "fullName": "Landing and jumping",
      "functionType": "Action",
      "name": "onPlatform",
      "sentence": "Landing and jumping for: _PARAM1_ Jump key: _PARAM2_ Falling speed: _PARAM3_ Start jump force: _PARAM4_ Final jump force: _PARAM5_ Jump height: _PARAM6_ Threshold jittering: _PARAM7_ Instant Z threshold: _PARAM8_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const keyNameToKeyCode = {",
            "    'a': 65,",
            "    'b': 66,",
            "    'c': 67,",
            "    'd': 68,",
            "    'e': 69,",
            "    'f': 70,",
            "    'g': 71,",
            "    'h': 72,",
            "    'i': 73,",
            "    'j': 74,",
            "    'k': 75,",
            "    'l': 76,",
            "    'm': 77,",
            "    'n': 78,",
            "    'o': 79,",
            "    'p': 80,",
            "    'q': 81,",
            "    'r': 82,",
            "    's': 83,",
            "    't': 84,",
            "    'u': 85,",
            "    'v': 86,",
            "    'w': 87,",
            "    'x': 88,",
            "    'y': 89,",
            "    'z': 90,",
            "    'space': 32,",
            "    'enter': 13,",
            "    'shift': 16,",
            "    'ctrl': 17,",
            "    'alt': 18,",
            "    'up': 38,",
            "    'down': 40,",
            "    'left': 37,",
            "    'right': 39",
            "};",
            "",
            "function setMeshOnPlatform(runtimeScene, meshName) {",
            "    const threeScene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "    const meshThree = threeScene.getObjectByName(meshName);",
            "    const meshGdevelopObjects = runtimeScene.getObjects(meshName);",
            "",
            "    if (meshGdevelopObjects.length === 0) {",
            "        return;",
            "    }",
            "",
            "    const meshGdevelop = meshGdevelopObjects[0];",
            "",
            "    if (meshThree) {",
            "        if (!meshThree.userData) {",
            "            meshThree.userData = {};",
            "        }",
            "",
            "        const ifIntersected = meshThree.userData.intersected;",
            "        const intersectedZ = meshThree.userData.intersectedZ || 0;",
            "        const playerZ = meshGdevelop.getCenterZInScene();",
            "        const halfDepth = meshGdevelop.getDepth() / 2;",
            "        const fallSpeed = eventsFunctionContext.getArgument(\"fallSpeed\");",
            "        const lerpFactor = 0.1;",
            "        const threshold = eventsFunctionContext.getArgument(\"threshold\");",
            "        const instantSetThreshold = eventsFunctionContext.getArgument(\"instantSetThreshold\");",
            "",
            "        const jumpForce = eventsFunctionContext.getArgument(\"jumpForce\");",
            "        const jumpKey = eventsFunctionContext.getArgument(\"jumpKey\");",
            "        const jumpHeight = eventsFunctionContext.getArgument(\"jumpHeight\");",
            "        const finalJumpForce = eventsFunctionContext.getArgument(\"finalJumpForce\"); ",
            "",
            "        const jumpKeyCode = keyNameToKeyCode[jumpKey.toLowerCase()];",
            "",
            "        if (!meshThree.userData.isJumping) {",
            "            meshThree.userData.isJumping = false;",
            "            meshThree.userData.jumpVelocity = 0;",
            "        }",
            "",
            "        const isJumping = meshThree.userData.isJumping;",
            "        let jumpVelocity = meshThree.userData.jumpVelocity;",
            "        const onPlatform = meshThree.userData.onPlatform;",
            "        let pauseTimer = meshThree.userData.pauseTimer || 0;",
            "",
            "        if (runtimeScene.getGame().getInputManager().isKeyPressed(jumpKeyCode) && onPlatform && ifIntersected) {",
            "            meshThree.userData.isJumping = true;",
            "            meshThree.userData.jumpVelocity = jumpForce;",
            "            meshThree.userData.targetZ = playerZ + jumpHeight;",
            "            meshThree.userData.pauseTimer = 0; // Reset the pause timer",
            "        }",
            "",
            "        if (isJumping) {",
            "            const targetZ = meshThree.userData.targetZ;",
            "            if (playerZ < targetZ) {",
            "                const progress = (playerZ - (targetZ - jumpHeight)) / jumpHeight;",
            "                const currentJumpForce = THREE.MathUtils.lerp(jumpForce, finalJumpForce, progress);",
            "                const nextFrameZ = THREE.MathUtils.lerp(playerZ, playerZ + currentJumpForce, lerpFactor);",
            "                meshGdevelop.setCenterZInScene(nextFrameZ);",
            "            } else {",
            "                if (pauseTimer < 0.1) { // Pause for 0.1 seconds",
            "                    meshThree.userData.pauseTimer += runtimeScene.getElapsedTime() / 1000; // Increment timer",
            "                } else {",
            "                    meshThree.userData.isJumping = false;",
            "                }",
            "            }",
            "        } else {",
            "            if (ifIntersected) {",
            "                if (Math.abs(intersectedZ + halfDepth - playerZ) < instantSetThreshold) {",
            "                    meshGdevelop.setCenterZInScene(intersectedZ + halfDepth);",
            "                    meshThree.userData.onPlatform = true;",
            "                } else if (intersectedZ + halfDepth < playerZ - threshold) {",
            "                    meshThree.userData.onPlatform = false;",
            "                    const nextFrameZ = THREE.MathUtils.lerp(playerZ, playerZ - fallSpeed, lerpFactor);",
            "                    meshGdevelop.setCenterZInScene(nextFrameZ);",
            "                } else if (intersectedZ + halfDepth > playerZ + threshold) {",
            "                    meshThree.userData.onPlatform = true;",
            "                    meshGdevelop.setCenterZInScene(intersectedZ + halfDepth);",
            "                }",
            "            } else {",
            "                meshThree.userData.onPlatform = false;",
            "                const nextFrameZ = THREE.MathUtils.lerp(playerZ, playerZ - fallSpeed, lerpFactor);",
            "                meshGdevelop.setCenterZInScene(nextFrameZ);",
            "            }",
            "        }",
            "",
            "        meshThree.userData.jumpVelocity = jumpVelocity;",
            "    }",
            "}",
            "",
            "if (objects.length > 0) {",
            "    var meshName = objects[0].getName();",
            "    setMeshOnPlatform(runtimeScene, meshName);",
            "}",
            ""
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Mesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "jumpKey",
          "name": "jumpKey",
          "type": "key"
        },
        {
          "description": "Falling speed",
          "name": "fallSpeed",
          "type": "expression"
        },
        {
          "description": "Start jump force",
          "name": "jumpForce",
          "type": "expression"
        },
        {
          "description": "Final jump force",
          "name": "finalJumpForce",
          "type": "expression"
        },
        {
          "description": "Jump height",
          "name": "jumpHeight",
          "type": "expression"
        },
        {
          "description": "Threshold jittering",
          "name": "threshold",
          "type": "expression"
        },
        {
          "description": "Instant Z set threshold",
          "name": "instantSetThreshold",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Is on platform",
      "fullName": "Is on platform",
      "functionType": "ExpressionAndCondition",
      "name": "IsOnPlatform",
      "sentence": "Is on platform: _PARAM1_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function getMeshOnPlatform(runtimeScene, meshName) {",
            "    const threeScene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "    const mesh = threeScene.getObjectByName(meshName);",
            "",
            "    if (mesh) {",
            "        return mesh.userData && mesh.userData.onPlatform || false;",
            "    }",
            "    return false;",
            "}",
            "",
            "if (objects.length > 0) {",
            "    var meshName = objects[0].getName();",
            "    const onPlatform = getMeshOnPlatform(runtimeScene, meshName);",
            "    eventsFunctionContext.returnValue = onPlatform;",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "supplementaryInformation": "[\"false\",\"true\"]",
        "type": "stringWithSelector"
      },
      "parameters": [
        {
          "description": "Mesh",
          "name": "id",
          "type": "objectList"
        }
      ],
      "objectGroups": []
    }
  ],
  "eventsBasedBehaviors": [],
  "eventsBasedObjects": []
}